@using System.Timers

<div class="timer-display-root">
    <div class="timer-container">
        <!-- Main Timer Display Area -->
        <div class="timer-visuals">
            <!-- Background Image -->
            <img src="@(TimerService.CurrentSessionType == SessionType.Pomodoro ? "images/pomodoro_focus.svg" : "images/break_chill.svg")" 
                 alt="Timer Background" 
                 class="timer-bg-image @(TimerService.CurrentState == TimerState.Running ? "pulsing" : "")" />
            
            <!-- Text Overlay -->
            <div class="timer-text-overlay">
                @FormatTime(TimerService.RemainingSeconds)
            </div>
        </div>
    </div>

    <div class="timer-controls-wrapper">
        <TimerControls State="@TimerService.CurrentState"
                       CurrentSessionType="@TimerService.CurrentSessionType"
                       CompletedPomodoros="@TimerService.CompletedPomodoros"
                       OnStart="StartTimer"
                       OnStartBreak="@(() => TimerService.StartBreak())"
                       OnPause="PauseTimer"
                       OnResume="ResumeTimer"
                       OnCancel="RequestCancel" />
    </div>
    
    <PomodoroFocus.Web.Components.Modals.CancelConfirmModal 
        IsVisible="@ShowCancelModal"
        OnClose="@(() => ShowCancelModal = false)"
        OnConfirmCompleted="HandleCompleted"
        OnConfirmNotCompleted="HandleNotCompleted" />
</div>

@using PomodoroFocus.Domain.Enums
@using PomodoroFocus.Application.Interfaces
@inject IPomodoroService TimerService
@inject IJSRuntime JSRuntime
@implements IDisposable

@code {
    // UI Local State for Modal
    private bool ShowCancelModal { get; set; } = false;

    // Computed properties for UI
    
    // Note: Progress ring calculations removed as per design change.
    
    protected override void OnInitialized()
    {
        TimerService.OnTimerTick += HandleTimerTick;
        TimerService.OnSessionComplete += HandleSessionComplete;
    }

    private void HandleTimerTick()
    {
        InvokeAsync(StateHasChanged);
    }

    private void HandleSessionComplete()
    {
        // Play sound
        JSRuntime.InvokeVoidAsync("playAudio", "alarm-sound");
        
        InvokeAsync(StateHasChanged);
    }

    private string FormatTime(int totalSeconds)
    {
        var time = TimeSpan.FromSeconds(totalSeconds);
        return $"{(int)time.TotalMinutes:D2}:{time.Seconds:D2}";
    }

    private void StartTimer() => TimerService.StartPomodoro();
    
    // For breaks, we need to know which one to start.
    // However, the interface has StartBreak() which auto-decides (logic in service).
    // But TimerControls might want to call StartPomodoro or StartBreak.
    // If state is Ready, we need to know what to start.
    
    private void PauseTimer() => TimerService.Pause();

    private void ResumeTimer() => TimerService.Resume();

    private void RequestCancel()
    {
        if (TimerService.CurrentState == TimerState.Running) TimerService.Pause();
        ShowCancelModal = true;
    }

    private void HandleCompleted()
    {
        ShowCancelModal = false;
        TimerService.CancelAsCompleted();
    }

    private void HandleNotCompleted()
    {
        ShowCancelModal = false;
        TimerService.CancelAsIncomplete();
    }

    public void Dispose()
    {
        TimerService.OnTimerTick -= HandleTimerTick;
        TimerService.OnSessionComplete -= HandleSessionComplete;
    }
}

<audio id="alarm-sound" src="sounds/alarm.mp3" preload="auto"></audio>

<script>
    window.playAudio = (elementId) => {
        var audio = document.getElementById(elementId);
        if (audio) {
            audio.currentTime = 0;
            audio.play();
        }
    }
</script>
